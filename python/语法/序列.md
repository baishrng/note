---
title: 序列
---

---

## 概述

Python中常用的序列结构有列表、元组、字符串，字典、集合以及range、zip、filter等对象也支持很多类似的操作。

列表（list）和元组（tuple）比较相似，它们都按顺序保存元素，所有的元素占用一块连续的内存

字典（dict）和集合（set）存储的数据都是无序的，每份元素占用不同的内存

<img src="../../img/python/语法/屏幕截图 2022-10-03 194857.jpg" style="zoom:50%;" />

|                        | **列表**               | **元组**               | **字典**                     | **集合**   |
| ---------------------- | ---------------------- | ---------------------- | ---------------------------- | ---------- |
| **类型名称**           | list                   | tuple                  | dict                         | set        |
| **定界符**             | 方括号[]               | 圆括号()               | 大括号{}                     | 大括号{}   |
| **是否可变**           | 是                     | 否                     | 是                           | 是         |
| **是否有序**           | 是                     | 是                     | 否                           | 否         |
| **是否支持下标**       | 是（使用序号作为下标） | 是（使用序号作为下标） | 是（使用“键”作为下标）       | 否         |
| **元素分隔符**         | 逗号                   | 逗号                   | 逗号                         | 逗号       |
| **对元素形式的要求**   | 无                     | 无                     | 键:值                        | 必须可哈希 |
| **对元素值的要求**     | 无                     | 无                     | “键”必须可哈希               | 必须可哈希 |
| **元素是否可重复**     | 是                     | 是                     | “键”不允许重复，“值”可以重复 | 否         |
| **元素查找速度**       | 非常慢                 | 很慢                   | 非常快                       | 非常快     |
| **新增和删除元素速度** | 尾部操作快其他位置慢   | 不允许                 | 快                           | 快         |

---

## 列表

列表是Python中内置有序、可变序列，列表的所有元素放在一对中括号[]中，并使用逗号分隔开；

当列表元素增加或删除时，列表对象自动进行扩展或收缩内存，保证元素之间没有缝隙；

一个列表中的数据类型可以各不相同。如

```
[10, 20, 30, 40]
['crunchy frog', 'ram bladder', 'lark vomit']
['spam', 2.0, 5, [10, 20]]
[['file1', 200,7], ['file2', 260,9]]
```

### 常用方法

| **方法**                          | **说明**                                                     |
| --------------------------------- | ------------------------------------------------------------ |
| `list(seq)`                       | 将元组转换为列表                                             |
| lst.append(x)                     | 将元素x添加至列表lst尾部                                     |
| lst.extend(L)                     | 将列表L中所有元素添加至列表lst尾部                           |
| lst.insert(index, x)              | 在列表lst指定位置index处添加元素x，该位置后面的所有元素后移一个位置 |
| lst.remove(x)                     | 在列表lst中删除首次出现的指定元素，该元素之后的所有元素前移一个位置 |
| lst.pop([index])                  | 删除并返回列表lst中下标为index（默认为-1）的元素             |
| lst.clear()                       | 删除列表lst中所有元素，但保留列表对象                        |
| lst.index(x)                      | 返回列表lst中第一个值为x的元素的下标，若不存在值为x的元素则抛出异常 |
| lst.count(x)                      | 返回指定元素x在列表lst中的出现次数                           |
| lst.reverse()                     | 对列表lst所有元素进行逆序                                    |
| lst.sort(key=None, reverse=False) | 对列表lst中的元素进行排序，key用来指定排序依据，reverse决定升序（False）还是降序（True） |
| lst.copy()                        | 返回列表lst的浅复制                                          |
| `len(list)`                       | 列表元素个数                                                 |
| `max(list)`                       | 返回列表元素最大值                                           |
| `min(list)`                       | 返回列表元素最小值                                           |

---

### 创建与删除

```
>>> a_list = ['a', 'b', 'mpilgrim', 'z', 'example']
>>> a_list = []                            #创建空列表
```

也可以使用list()函数将元组、range对象、字符串或其他类型的可迭代对象(可作用于for循环的对象叫可迭代对象)类型的数据转换为列表。

```
>>> a_list = list((3,5,7,9,11))
>>> a_list
[3, 5, 7, 9, 11]
>>> list(range(1,10,2))
[1, 3, 5, 7, 9]
>>> list('hello world')
['h', 'e', 'l', 'l', 'o', ' ', 'w', 'o', 'r', 'l', 'd']
>>> x = list()                            #创建空列表
```

当不再使用时，使用del命令删除整个列表。

```python
>>> tmp_list = list()
>>> del tmp_list
>>> tmp_list
Traceback (most recent call last):
  File "<pyshell#2>", line 1, in <module>
    tmp_list
NameError: name 'tmp_list' is not defined
```

----

### 列表元素的添加

（1）可以使用“+”运算符将元素添加到列表中。

```python
>>> aList = [3,4,5]
>>> aList = aList + [7]
>>> aList
[3, 4, 5, 7]
```

严格意义上来讲，这并不是真的为列表添加元素，而是创建了一个新列表，并将原列表中的元素和新元素依次复制到新列表的内存空间。由于涉及大量元素的复制，该操作速度较慢，在涉及大量元素添加时不建议使用该方法。

+更多的是用来拼接列表，而且执行效率并不高。

（2）使用列表对象的append()方法在当前列表尾部追加元素，原地修改列表，是真正意义上的在列表尾部添加元素，速度较快。

Python采用的是基于值的自动内存管理方式，修改对象：当为对象修改值时，并不是真的直接修改变量的值，而是使变量指向新的值，这对于Python所有类型的变量都是一样的。

```python
>>> a = [1,2,3]
>>> id(a)
2337439587584
>>> a = [1,2]
>>> id(a)
2337437401792
```

列表中包含的是元素值的引用，而不是直接包含元素值。

如果是直接修改序列变量的值，则与Python普通变量的情况是一样的

如果是通过下标来修改序列中元素的值或通过可变序列对象自身提供的方法来增加和删除元素时，序列对象在内存中的起始地址是不变的，仅仅是被改变值的元素地址发生变化，也就是所谓的“原地操作”。

```python
>>> a = [1, 2, 3]
>>> id(a)
2389572193096
>>> a.append(4)
>>> a.remove(3)
>>> a[0] = 5
>>> a
[5, 2, 4]
>>> id(a)
2389572193096
```

（3）使用列表对象的extend()方法可以将另一个迭代对象的所有元素添加至该列表对象尾部。通过extend()方法来增加列表元素也不改变其内存首地址，属于原地操作。

运算符+=类似于列表的extend()方法。

（4）使用列表对象的insert()方法将元素添加至列表的指定位置。

应尽量从列表尾部进行元素的增加与删除操作。

列表的insert()可以在列表的任意位置插入元素，但由于列表的自动内存管理功能，insert()方法会引起插入位置之后所有元素的移动，这会影响处理速度。

（5）使用乘法来扩展列表对象，将列表与整数相乘，生成一个新列表，新列表是原列表中元素的重复。

```python
>>> a = [1,2,3]
>>> a * 3
[1, 2, 3, 1, 2, 3, 1, 2, 3]
```

当使用*运算符将包含列表的列表重复并创建新列表时，并不是复制子列表值，而是复制已有元素的引用。因此，当修改其中一个值时，相应的引用也会被修改。

```python
>>> x = [[None] * 2] * 3
>>> x
[[None, None], [None, None], [None, None]]
>>> x[0][0] = 5
>>> x
[[5, None], [5, None], [5, None]]
```

---

### 列表元素的删除

（1）使用del命令删除列表中的指定位置上的元素。

```python
>>> a_list = [3,5,7,9,11]
>>> del a_list[1]
>>> a_list
[3, 7, 9, 11]
```

（2）使用列表的pop()方法删除并返回指定位置（默认为最后一个）上的元素，如果给定的索引超出了列表的范围则抛出异常。

（3）使用列表对象的remove()方法删除首次出现的指定元素，如果列表中不存在要删除的元素，则抛出异常。

**注意：**当在删除列表元素时，Python会自动对列表内存进行收缩并移动列表元素以保证所有元素之间没有空隙，增加列表元素时也会自动扩展内存并对元素进行移动以保证元素之间没有空隙。每当插入或删除一个元素之后，该元素位置后面所有元素的索引就都改变了。

---

### 列表元素访问与计数

（1）使用下标直接访问列表元素，如果指定下标不存在，则抛出异常。

（2）使用列表对象的index()方法获取指定元素**首次出现**的下标，若列表对象中不存在指定元素，则抛出异常。

（3）使用列表对象的count()方法统计指定元素在列表对象中出现的次数。

---

### 成员资格判断

使用in关键字来判断一个值是否存在于列表中，返回结果为“True”或“False”。

```python
>>> a = [1,2,3]
>>> 2 in a
True
>>> 4 in a
False
```

---

### 切片操作

切片适用于列表、元组、字符串、range对象等类型，但作用于列表时功能最强大。可以使用切片来截取列表中的任何部分，得到一个新列表，也可以通过切片来修改和删除列表中部分元素，甚至可以通过切片操作为列表对象增加元素。

切片使用2个冒号分隔的3个数字来完成：
第一个数字表示切片开始位置（默认为0）。
第二个数字表示切片截止（但不包含）位置（默认为列表长度）。
第三个数字表示切片的步长（默认为1），当步长省略时可以顺便省略最后一个冒号，当step为负数时，表示从负方向遍历

切片操作不会因为下标越界而抛出异常，而是简单地在列表尾部截断或者返回一个空列表，代码具有更强的健壮性。

```python
>>> aList = [3, 4, 5, 6, 7, 9, 11, 13, 15, 17]
>>> aList[::]                            #返回包含所有元素的新列表
[3, 4, 5, 6, 7, 9, 11, 13, 15, 17]
>>> aList[::-1]                          #逆序的所有元素
[17, 15, 13, 11, 9, 7, 6, 5, 4, 3]
>>> aList[::2]                           #偶数位置，隔一个取一个
[3, 5, 7, 11, 15]
>>> aList[1::2]                          #奇数位置，隔一个取一个
[4, 6, 9, 13, 17]
>>> aList[3::]                           #从下标3开始的所有元素
[6, 7, 9, 11, 13, 15, 17]
>>> aList[3:6]                           #下标在[3, 6)之间的所有元素
[6, 7, 9]
>>> aList[0:100:1]                       #前100个元素，自动截断
[3, 4, 5, 6, 7, 9, 11, 13, 15, 17]
>>> aList[100:]                          #下标100之后的所有元素，自动截断
[]
>>> aList[100]                           #直接使用下标访问会发生越界
IndexError: list index out of range
```

可以使用切片来**原地修改**列表内容

```python
>>> aList = [3, 5, 7]
>>> aList[len(aList):] = [9]      #在尾部追加元素
>>> aList
[3, 5, 7, 9]
>>> aList[:3] = [1, 2, 3]         #替换前3个元素
>>> aList
[1, 2, 3, 9]
>>> aList[:3] = []                #删除前3个元素
>>> aList
[9]
>>> aList = list(range(10))
>>> aList
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
>>> aList[::2] = [0]*5            #替换偶数位置上的元素
>>> aList
[0, 1, 0, 3, 0, 5, 0, 7, 0, 9]
>>> aList[::2] = [0]*3            #切片不连续，两侧元素个数必须一样多
ValueError: attempt to assign sequence of size 3 to extended slice of size 5
```

使用del与切片结合来删除列表元素

```python
>>> aList = [3,5,7,9,11]
>>> del aList[:3]                          #删除前3个元素
>>> aList
[9, 11]

>>> aList = [3,5,7,9,11]
>>> del aList[::2]                         #删除偶数位置上的元素
>>> aList
[5, 9]
```

切片返回的是浅复制。所谓浅复制，是指生成一个新的列表，并且把原列表中所选元素的引用都复制到新列表中。如果原列表中只包含整数、实数、复数等基本类型或元组、字符串这样的不可变类型的数据，一般是没有问题的。

```python
>>> aList = [3, 5, 7]
>>> bList = aList[::]                 #切片，浅复制
>>> aList == bList                    #两个列表的元素完全一样
True
>>> aList is bList                    #但不是同一个对象
False
>>> id(aList) == id(bList)            #内存地址不一样
False
>>> bList[1] = 8                      #修改其中一个不会影响另一个
>>> bList
[3, 8, 7]
>>> aList
[3, 5, 7]
```

如果原列表中包含列表之类的可变数据类型，由于浅复制时只是把子列表的引用复制到新列表中，这样的话修改任何一个都会影响另外一个。

```python
>>> aList = [3, 5, 7]
>>> bList = aList[:]           #切片，浅复制
>>> aList == bList             #切片刚完成的瞬间，bList和aList中包含同样的元素引用
True
>>> bList[1] = 8               #列表中只包含可哈希对象，修改bList时不影响aList
>>> bList
[3, 8, 7]
>>> aList
[3, 5, 7]
>>> aList = [3, [5], 7]        #列表aList中包含可变的列表对象
>>> bList = aList[:]           #切片
>>> bList[1].append(6)         #调用子列表的append()方法，这个方法是原地操作的
>>> bList
[3, [5, 6], 7]
>>> aList                      #aList受到影响
[3, [5, 6], 7]
```

标准库copy中的deepcopy()函数实现深复制。所谓深复制，是指对原列表中的元素进行递归，把所有的值都复制到新列表中，对嵌套的子列表不再是复制引用。新列表和原列表是互相独立，修改任何一个都不会影响另外一个。

---

### 列表排序

（1）使用列表对象的sort()方法进行原地排序，支持多种不同的排序方法。

sort()方法没有返回值。

```python
>>> aList = [3, 4, 5, 6, 7, 9, 11, 13, 15, 17]
>>> import random
>>> random.shuffle(aList)
>>> aList
[3, 4, 15, 11, 9, 17, 13, 6, 7, 5]
>>> aList.sort()                            #默认是升序排序
>>> aList
[3, 4, 5, 6, 7, 9, 11, 13, 15, 17]
>>> aList.sort(reverse=True)              #降序排序
>>> aList
[17, 15, 13, 11, 9, 7, 6, 5, 4, 3]
>>> aList.sort(key=lambda x:len(str(x)))  #按转换成字符串的长度排序
>>> aList
[9, 7, 6, 5, 4, 3, 17, 15, 13, 11]
```

（2）使用内置函数sorted()对列表进行排序并返回新列表。

```python
>>> aList
[9, 7, 6, 5, 4, 3, 17, 15, 13, 11]
>>> sorted(aList)                            #升序排序
[3, 4, 5, 6, 7, 9, 11, 13, 15, 17]
>>> sorted(aList,reverse=True)             #降序排序
[17, 15, 13, 11, 9, 7, 6, 5, 4, 3]
```

（3）使用列表对象的reverse()方法将元素原地逆序。没有返回

（4）使用内置函数reversed()对列表元素进行逆序排列并返回迭代对象。

---

### 列表推导式

列表推导式语法形式为：

[expression for expr1 in sequence1 if condition1
            for expr2 in sequence2 if condition2
            for expr3 in sequence3 if condition3
            ...
            for exprN in sequenceN if conditionN]

如：

```
>>> aList = [x*x for x in range(10)]
相当于

>>> aList = []
>>> for x in range(10):
	    aList.append(x*x)

也相当于

>>> aList = list(map(lambda x: x*x, range(10)))
```

```python
# 使用列表推导式实现嵌套列表的平铺
>>> vec = [[1,2,3], [4,5,6], [7,8,9]] 
>>> [num for elem in vec for num in elem] #外层循环，内层循环
[1, 2, 3, 4, 5, 6, 7, 8, 9] 
```

```python
# 过滤不符合条件的元素
>>> aList = [-1,-4,6,7.5,-2.3,9,-11]
>>> [i for i in aList if i>0]
[6, 7.5, 9]
```

```python
# 在列表推导式中使用多个循环，实现多序列元素的任意组合
>>> [(x, y) for x in range(3) for y in range(3)]
[(0, 0), (0, 1), (0, 2), (1, 0), (1, 1), (1, 2), (2, 0), (2, 1), (2, 2)]
>>> [(x, y) for x in [1, 2, 3] for y in [3, 1, 4] if x != y]
[(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]
```

---

### 代码

```python
# 列表
k = [1,2,3,4,5]            #列表的定义
print(k)
k.append('小甲鱼')          #列表的添加，在末尾
print(k)
k.extend(['hai','hio'])    #列表的添加，在末尾
print(k)
k.insert(2,78)             #列表的添加，insert(位置，添加的数据)
print(k)
print(k[4])                #调用列表中的某个值

k.remove('小甲鱼')         #移除列表中的某个值
print(k)
del k[5]                  #del 是一个语句，移除列表中的某个位置的数据，如果 del k 则表示把整个列表删除
print(k)
k.pop()                   #pop移除方式是根据python栈的储存方式来的，意味弹出栈，如果（）中不添加任何值，则表示弹出列表的最后一个
print(k)
k.pop(2)
print(k)

print(k[1:4])            #列表的分片拷贝

k1 = k[:]                # 尽量不要用 k1 = k 因为这样用，k修改了，k1也要跟着修改
print(k1)

k2 = []                 # 空列表
print(k2)
```

结果：

```
[1, 2, 3, 4, 5]
[1, 2, 3, 4, 5, '小甲鱼']
[1, 2, 3, 4, 5, '小甲鱼', 'hai', 'hio']
[1, 2, 78, 3, 4, 5, '小甲鱼', 'hai', 'hio']
4
[1, 2, 78, 3, 4, 5, 'hai', 'hio']
[1, 2, 78, 3, 4, 'hai', 'hio']
[1, 2, 78, 3, 4, 'hai']
[1, 2, 3, 4, 'hai']
[2, 3, 4]
[1, 2, 3, 4, 'hai']
[]
```

```python
k1 = [123, 456]
k2 = [234, 345]
print(k1 > k2)          # 列表的比较，从第0个元素开始比较
k3 = k1 + k2            # 字符串的拼接
print(k3)
k1 = k1 * 3             # 将列表中的元素乘以倍数再添加到列表的后面
print(k1)
print(345 in k3)        # 检查元素是否在列表中
k4 = [123, 234, [456, 789]]     # 如果要引用456的话要这样表示 k4[2][0]
print(789 in k4[2])            # 检查列表中的列表元素中的，某个元素是否存在
print(k1.count(456))            # count 函数用来统计列表中某个元素出现的次数
print(k1.index(456))            # index 函数用来查找列表中某个元素所处的位置
print(k1.index(123, 1, 4))       # index(要查找的元素，查找的起始位置，查找的终止位置)
k5 = [4, 2, 6, 9, 3, 1, 0, 5]
k5.sort()                       #  将列表中元素按从小到大排序
print(k5)
k5.reverse()               # 将列表倒序
print(k5)

X = [[12, 7, 3],        # 相当于c语言中数组的用法，引用为X[1][1].
     [4, 5, 6],
     [7, 8, 9]]
```

结果：

```
False
[123, 456, 234, 345]
[123, 456, 123, 456, 123, 456]
True
True
3
1
2
[0, 1, 2, 3, 4, 5, 6, 9]
[9, 6, 5, 4, 3, 2, 1, 0]
```



---

## 元组

元组和列表类似，但属于不可变序列，元组一旦创建，用任何方法都不可以修改其元素。

元组的定义方式和列表相同，但定义时所有元素是放在一对圆括号“（）”中，而不是方括号中。

### 元组的创建与删除

1、使用“=”将一个元组赋值给变量

```python
>>> a_tuple = ('a', 'b', 'mpilgrim', 'z', 'example')
>>> a_tuple
('a', 'b', 'mpilgrim', 'z', 'example')
>>> a = (3)
>>> a
3
>>> a = (3,)             #包含一个元素的元组，最后必须多写个逗号
>>> a
(3,)
>>> a = 3,               #也可以这样创建元组
>>> a
(3,)
>>> x = ()               #空元组
```

2、使用tuple函数将其他序列转换为元组

```python
>>> tuple('abcdefg')                    #把字符串转换为元组
('a', 'b', 'c', 'd', 'e', 'f', 'g')
```

**注意：**使用del可以删除元组对象，不能删除元组中的元素

| Python 表达式                | 结果                         | 描述         |
| ---------------------------- | ---------------------------- | ------------ |
| len((1, 2, 3))               | 3                            | 计算元素个数 |
| (1, 2, 3) + (4, 5, 6)        | (1, 2, 3, 4, 5, 6)           | 连接         |
| ('Hi!',) * 4                 | ('Hi!', 'Hi!', 'Hi!', 'Hi!') | 复制         |
| 3 in (1, 2, 3)               | True                         | 元素是否存在 |
| for x in (1, 2, 3): print(x) | 1 2 3                        | 迭代         |

| 方法         | 描述                 |
| ------------ | -------------------- |
| `len(tuple)` | 计算元组元素个数     |
| `max(tuple)` | 返回元组中元素最大值 |
| `min(tuple)` | 返回元组中元素最小值 |
| `tuple(seq)` | 将列表转换为元组     |

---

### 元组与列表的区别

1、元组一旦定义就不允许更改。

2、元组没有append()、extend()和insert()等方法，无法向元组中添加元素。

3、元组没有remove()或pop()方法，也无法对元组元素进行del操作，不能从元组中删除元素。

4、元组的速度比列表更快。如果定义了一系列常量值，而所需做的仅是对它进行遍历，那么一般使用元组而不用列表。

5、元组对不需要改变的数据进行“写保护”将使得代码更加安全。

6、元组可用作字典的“键”，也可以作为集合的元素。列表不能作为字典的“键”，包含列表、字典、集合或其他类型可变对象的元组也不能做字典的“键”。

7、如果元组中包含列表或其他类型的可变对象，这些对象是可变的，但元组元素的引用仍是不可变的。

```python
>>> x = ([1,2],3)
>>> x[0][0] = 5
>>> x
([5, 2], 3)
>>> x[0] = [4,5]
Traceback (most recent call last):
  File "<pyshell#13>", line 1, in <module>
    x[0] = [4,5]
TypeError: 'tuple' object does not support item assignment
```

---

### 生成器推导式

生成器推导式的结果是一个**生成器对象**。

使用生成器对象的元素时，可以根据需要将其转化为列表或元组，也可以使用生成器对象\__next__()方法或内置函数next()进行遍历，或者直接将其作为迭代器对象来获取元素。

生成器对象具有惰性求值的特点，只在需要时生成新元素，空间占用非常少，尤其适合大数据处理的场合。

**不管用哪种方法访问生成器对象，都无法再次访问已访问过的元素。**

```python
>>> g = ((i+2)**2 for i in range(10))  #创建生成器对象
>>> g
<generator object <genexpr> at 0x0000000003095200>
>>> tuple(g)                           #将生成器对象转换为元组
(4, 9, 16, 25, 36, 49, 64, 81, 100, 121)
```

---

## 字典

字典是无序、可变序列。

定义字典时，每个元素的键和值用冒号分隔，元素之间用逗号分隔，所有的元素放在一对大括号“｛｝”中。

字典中的**键可以为任意不可变数据**，比如整数、实数、复数、字符串、元组等等。

globals()返回包含当前作用域内所有全局变量和值的字典。

locals()返回包含当前作用域内所有局部变量和值的字典。

---

### 字典的创建与删除

1、使用=将一个字典赋值给一个变量

```python
>>> a_dict = {'server': 'db.diveintopython3.org', 'database': 'mysql'}
>>> a_dict
{'database': 'mysql', 'server': 'db.diveintopython3.org'}
>>> x = {}                     #空字典
>>> x
{}
```

2、使用dict利用已有数据创建字典

```python
>>> keys = ['a', 'b', 'c', 'd']
>>> values = [1, 2, 3, 4]
>>> dictionary = dict(zip(keys, values))
>>> dictionary
{'a': 1, 'b': 2, 'c': 3, 'd': 4}
>>> x = dict() #空字典
>>> x
{}
```

3、使用dict根据给定的键、值创建字典

```python
>>> d = dict(name='Dong', age=37)
```

4、以给定内容为键，创建值为空的字典

```python
>>> adict = dict.fromkeys(['name', 'age', 'sex'])
>>> adict
{'name': None, 'age': None, 'sex': None}
```

5、可以使用del删除整个字典

---

### 字典元素的读取

（1）以键作为下标可以读取字典元素，若键不存在则抛出异常

```python
>>> aDict = {'name':'Dong', 'sex':'male', 'age':37}
>>> aDict['name']
'Dong'
>>> aDict['tel']                     #键不存在，抛出异常
Traceback (most recent call last):
  File "<pyshell#53>", line 1, in <module>
    aDict['tel']
KeyError: 'tel'
```

（2）使用字典对象的get()方法获取指定键对应的值，并且可以在键不存在的时候返回指定值。

```python
>>> print(aDict.get('address'))
None
>>> print(aDict.get('address', 'SDIBT'))
SDIBT
```

（3）使用字典对象的items()方法可以返回字典的元素。

使用字典对象的keys()方法可以返回字典的“键”。

使用字典对象的values()方法可以返回字典的“值”。

```python
>>> aDict={'name':'Dong', 'sex':'male', 'age':37}
>>> for item in aDict.items():     #输出字典中所有元素
    print(item)

('age', 37)
('name', 'Dong')
('sex', 'male')
>>> for key in aDict:              #不加特殊说明，默认输出“键”
    print(key)

age
name
sex
>>> for key, value in aDict.items():       #序列解包用法
    print(key, value)

age 37
name Dong
sex male
>>> aDict.keys()                           #返回所有“键”
dict_keys(['name', 'sex', 'age'])
>>> aDict.values()                         #返回所有“值”
dict_values(['Dong', 'male', 37])

```

---

### 字典元素的添加与修改

（1）当以指定键为下标为字典赋值时：1）若键存在，则可以修改该键的值；2）若不存在，则表示添加一个键、值对。

（2）使用字典对象的update()方法将另一个字典的键、值对添加到当前字典对象。

```python
>>> aDict
{'age': 37, 'score': [98, 97], 'name': 'Dong', 'sex': 'male'}
>>> aDict.items()
dict_items([('age', 37), ('score', [98, 97]), ('name', 'Dong'), ('sex', 'male')])
>>> aDict.update({'a':'a','b':'b'})
>>> aDict
{'a': 'a', 'score': [98, 97], 'name': 'Dong', 'age': 37, 'b': 'b', 'sex': 'male'}
```

（3）使用del删除字典中指定键的元素

（4）使用字典对象的clear()方法来删除字典中所有元素

（5）使用字典对象的pop()方法删除并返回指定键的元素

（6）使用字典对象的popitem()方法删除并返回字典中的一个元素

---

### 字典推导式

```python
>>> s = {x:x.strip() for x in ('  he  ', 'she    ', '    I')}
>>> s
{'  he  ': 'he', '    I': 'I', 'she    ': 'she'}

>>> {i:str(i) for i in range(1, 5)}
{1: '1', 2: '2', 3: '3', 4: '4'}
>>> x = ['A', 'B', 'C', 'D']
>>> y = ['a', 'b', 'b', 'd']
>>> {i:j for i,j in zip(x,y)}
{'A': 'a', 'C': 'b', 'B': 'b', 'D': 'd'}
```

---

### 方法和函数

| 方法和函数     | 描述                                             |
| -------------- | ------------------------------------------------ |
| len(dict)      | 计算字典元素个数                                 |
| str(dict)      | 输出字典可打印的字符串表示                       |
| type(variable) | 返回输入的变量类型，如果变量是字典就返回字典类型 |
| dict.clear()   | 删除字典内所有元素                               |
| dict.copy()    | 返回一个字典的浅复制                             |
| dict.values()  | 以列表返回字典中的所有值                         |
| popitem()      | 随机返回并删除字典中的一对键和值                 |
| dict.items()   | 以列表返回可遍历的(键, 值) 元组数组              |

---

## 集合

集合是无序、可变序列，使用一对大括号界定，元素不可重复，同一个集合中每个元素都是唯一的。

集合中只能包含数字、字符串、元组等不可变类型（或者说可哈希）的数据，而不能包含列表、字典、集合等可变类型的数据。

### 集合的创建与删除

（1）直接将集合赋值给变量

```python
>>> a = {3, 5}
```

（2）使用`set()`将其他类型数据转换为集合

```python
>>> a_set = set(range(8,14))
>>> a_set
{8, 9, 10, 11, 12, 13}
>>> b_set = set([0, 1, 2, 3, 0, 1, 2, 3, 7, 8])   #自动去除重复
>>> b_set
{0, 1, 2, 3, 7, 8}
>>> c_set = set()                                 #空集合
>>> c_set
set()
```

（3）当不再使用某个集合时，可以使用del命令删除整个集合。集合对象的pop()方法弹出并删除其中一个元素，remove()方法直接删除指定元素，clear()方法清空集合

---

### 集合运算

（1）交集、并集、差集、对称差集等运算

```python
>>> a_set = set([8, 9, 10, 11, 12, 13])
>>> b_set = {0, 1, 2, 3, 7, 8}
>>> a_set | b_set                             #并集
{0, 1, 2, 3, 7, 8, 9, 10, 11, 12, 13}
>>> a_set & b_set                             #交集
{8}
>>> a_set - b_set
{9, 10, 11, 12, 13}
>>> a_set ^ b_set                             #对称差集
{0, 1, 2, 3, 7, 9, 10, 11, 12, 13}
```

（2）集合包含关系测试

```python
>>> x = {1, 2, 3}
>>> y = {1, 2, 5}
>>> z = {1, 2, 3, 4}
>>> x < y                                #比较集合大小/包含关系
False
>>> x < z                                #真子集
True
>>> y < z
False
>>> {1, 2, 3} <= {1, 2, 3}               #子集
True
```

---

### 集合推导式

```
>>> s = {x.strip() for x in ('  he  ', 'she    ', '    I')}
>>> s
{'I', 'she', 'he'}
```

---

### 代码

```python
set1 = {3,4,6,7,8,9}            # 创建一个集合
print(set1)
set2 = set([1,2,3,8,4,5,2])       # 创建集合
print(set2)

set2.add(5)             # 增加
set2.remove(8)          # 去掉,如果 8 不在集合中会报错
set2.discard(2)         # 去掉,如果 2 不在集合中不会报错
set1.clear()            # 移除集合中所有的元素
print(set2)
set2.pop()
print(set2)             # 弹出一个元素
set1 = set2.copy()      # 集合复制

set3 = frozenset([7,6,5,3,8])           # 锁定集合，不能对集合进行操作

k1 = {0,1,2,3,4,5}
k2 = set([4,5,6,7,8,9])
k3 = {1,2,3,4}

bin = k1|k2                # 返回一个新集合，包括在集合k1和k2中的所有元素(并集)
print("bin=",bin)
cha = k1-k2                 # 返回一个新集合，包括在集合k1但不在k2中的元素(差集)
print("cha=",cha)
jiao = k1&k2                # 返回一个新集合，包括同时在集合k1和k2中的元素(交集)
print("jiao=",jiao)
fei = k1^k2                 # 返回一个新集合，包括集合k1和k2中的非相同元素(对称差集)
print("fei=",fei)

print(k3<k1)                # 返回Ture/False,判断是否具有包含关系
print(k3>=k2)

k1 = k1|k2
print(k1)
```



---

## 用于序列操作的常用内置函数

1、`all()和any()：`

all()函数用来测试列表、元组等序列对象以及map对象、zip对象等类似对象中是否所有元素都等价于True，any()函数用来测试序列或可迭代对象中是否存在等价于True的元素。例如：

```python
>>> all([1,2,3])
True
>>> all([0,1,2,3])
False
>>> any([0,1,2,3])
True
>>> any([0])
False
```

2、`len(列表)`

返回列表中的元素个数，同样适用于元组、字典、集合、字符串等

3、`max(列表)、 min(列表)`

返回列表中的最大或最小元素，同样适用于元组、字典、集合、range对象等。

4、`sum(列表)`

对列表的元素进行求和运算，对非数值型列表运算需要指定start参数，同样适用于元组、range

```python
>>> sum(range(1, 11))      #sum()函数的start参数默认为0
55
>>> sum(range(1, 11), 5)   #指定start参数为5，等价于5+sum(range(1,11))
60
>>> sum([[1, 2], [3], [4]], [])    #这个操作占用空间较大，慎用
[1, 2, 3, 4]
```

4、`zip()`

zip()函数它可以将多个序列（列表、元组、字典、集合、字符串以及 range() 区间构成的列表）“压缩”成一个 zip 对象。所谓“压缩”，其实就是将这些序列中对应位置的元素重新组合，生成一个个新的元组。

如果各个迭代器的元素个数不一致，则返回列表长度与最短的对象相同，利用 * 号操作符，可以将元组解压为列表。

```python
>>> aList = [1, 2, 3]
>>> bList = [4, 5, 6]
>>> cList = zip(a, b)                 #返回zip对象
>>> cList
<zip object at 0x0000000003728908>
>>> list(cList)                       #把zip对象转换成列表
[(1, 4), (2, 5), (3, 6)]
```

5、`enumerate(列表)`

枚举列表元素，返回枚举对象，其中每个元素为包含下标和值的元组。该函数对元组、字符串同样有效。

```python
>>> for item in enumerate('abcdef'):
    print(item)

(0, 'a')
(1, 'b')
(2, 'c')
(3, 'd')
(4, 'e')
(5, 'f')
```

6、`sort()和sorted()`

sort()方法支持原地排序，而内置函数sorted()返回新列表，并不对原列表进行任何修改。

sorted()方法可以对列表、元组、字典、range对象等进行排序。

列表的sort()方法和内置函数sorted()都支持key参数实现复杂排序要求。

---

## 序列解包和序列封包

把多个值赋给一个变量时，Python会自动的把多个值封装成元组，称为序列封包。

把一个序列（列表、元组、字符串等）直接赋给多个变量，此时会把序列中的各个元素依次赋值给每个变量，但是**元素的个数需要和变量个数相同**，这称为序列解包。

```python
# 序列解包
>>> x, y, z = 1, 2, 3             #多个变量同时赋值
>>> v_tuple = (False, 3.5, 'exp')
>>> (x, y, z) = v_tuple
>>> x, y, z = v_tuple
```

Python 3.5之后的版本还支持下面用法的序列解包:`运算符*和运算符**`

```python
>>> print(*[1, 2, 3], 4, *(5, 6))
1 2 3 4 5 6
>>> *range(4),4
(0, 1, 2, 3, 4)
>>> {*range(4), 4, *(5, 6, 7)}
{0, 1, 2, 3, 4, 5, 6, 7}
>>> {'x': 1, **{'y': 2}}
{'y': 2, 'x': 1}
```

---

## 自定义序列（容器）

常见的容器类型有: dict, tuple, list, string。其中也提到过可容器和不可变容器的概念。其中 tuple, string 是不可变容器，dict, list 是可变容器。

可变容器和不可变容器的区别在于，不可变容器一旦赋值后，不可对其中的某个元素进行修改。

那么这里先提出一个问题，这些数据结构就够我们开发使用吗？

不够的时候，或者说有些特殊的需求不能单单只使用这些基本的容器解决的时候，该怎么办呢？

这个时候就需要自定义容器了，那么具体我们该怎么做呢？

| 功能                                                         | 说明                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 自定义不可变容器类型                                         | 需要定义 `__len__` 和 `__getitem__` 方法                     |
| 自定义可变类型容器                                           | 在不可变容器类型的基础上增加定义 `__setitem__` 和 `__delitem__` |
| 自定义的数据类型需要迭代                                     | 需定义 `__iter__`                                            |
| 返回自定义容器的长度                                         | 需实现 `__len__(self)`                                       |
| 自定义容器可以调用 `self[key]` ，如果 key 类型错误，抛出TypeError ，如果没法返回key对应的数值时,该方法应该抛出ValueError | 需要实现 `__getitem__(self, key)`                            |
| 当执行 `self[key] = value` 时                                | 调用是 `__setitem__(self, key, value)`这个方法               |
| 当执行 `del self[key]` 方法                                  | 其实调用的方法是 `__delitem__(self, key)`                    |
| 当你想你的容器可以执行 `for x in container:` 或者使用 `iter(container)` 时 | 需要实现 `__iter__(self)` ，该方法返回的是一个迭代器         |

来看一下使用上面魔术方法实现 Haskell 语言中的一个数据结构：

```python
#https://github.com/walter201230/Python/blob/master/Article/PythonBasis/python10/5.md
# -*- coding: UTF-8 -*-

class FunctionalList:
    ''' 实现了内置类型list的功能,并丰富了一些其他方法: head, tail, init, last, drop, take'''

    def __init__(self, values=None):
        if values is None:
            self.values = []
        else:
            self.values = values

    def __len__(self):
        return len(self.values)

    def __getitem__(self, key):
        return self.values[key]

    def __setitem__(self, key, value):
        self.values[key] = value

    def __delitem__(self, key):
        del self.values[key]

    def __iter__(self):
        return iter(self.values)

    def __reversed__(self):
        return FunctionalList(reversed(self.values))

    def append(self, value):
        self.values.append(value)

    def head(self):
        # 获取第一个元素
        return self.values[0]

    def tail(self):
        # 获取第一个元素之后的所有元素
        return self.values[1:]

    def init(self):
        # 获取最后一个元素之前的所有元素
        return self.values[:-1]

    def last(self):
        # 获取最后一个元素
        return self.values[-1]

    def drop(self, n):
        # 获取所有元素，除了前N个
        return self.values[n:]

    def take(self, n):
        # 获取前N个元素
        return self.values[:n]
```

